# -*- coding: utf-8 -*-
"""LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K3J1JgZEx532z-k90wwz3iNgUfIsrgyu
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

import tensorflow as tf
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, LSTM

mnist = tf.keras.datasets.mnist
(x, y),(x_test, y_test) = mnist.load_data()

print(x.shape)

print(x.shape[1:])

##Adding the preprocessing Unit
#Extracting validation set normalizing the data
x_train = (x[:50000])/255.0
x_val = (x[50000:])/255.0
y_train = y[:50000]
y_val = y[50000:]
# print(x_train.shape)
# print(y_train.shape)
# print(x_val.shape)
# print(y_val.shape)
# print(x_train[0])
num_classes = 10
y_train = to_categorical(y_train, num_classes)
y_val = to_categorical(y_val, num_classes)
y_test = to_categorical(y_test, num_classes)

##setiing the parameters
epochs = 15
lr = 0.1
decay = 1e-5
batch_size = 128

##The data is in sequence already
fig, axes = plt.subplots(nrows=1, ncols=2, figsize = (25,5))
for i in range(1,4):
  model = Sequential()
  if i==1:
    model.add(LSTM(128, input_shape= (x_train.shape[1:]), activation='relu'))
  else:
    model.add(LSTM(128, input_shape= (x_train.shape[1:]), activation='relu', return_sequences=True))
    for j in range(2,i):
      model.add(LSTM(128, activation='relu', return_sequences=True))
    model.add(LSTM(128, activation='relu'))
  model.add(Dense(10, activation='softmax'))

  sgd = tf.keras.optimizers.SGD(lr=lr)

  model.compile(loss='mean_squared_error', optimizer = sgd, metrics=['accuracy'])
  history_lstm = model.fit(x_train, y_train, epochs=epochs, verbose=1, validation_data=(x_val, y_val))
  Accuracy_validation = history_lstm.history['val_acc']
  Accuracy_training = history_lstm.history['acc']
  test_accuracy = model.evaluate(x_test, y_test)
  print("The testing accuracy metric for %s no. of lstm layers is %s" % (i, test_accuracy))
  print("---------------------------------------------------")
  axes[0].plot(np.arange(1,epochs+1),Accuracy_validation,label="lstm_layers=%s"%(i))
  axes[1].plot(np.arange(1,epochs+1),Accuracy_training,label="lstm_layers=%s"%(i))
axes[0].grid(True)
axes[0].set_xlabel("--- Epochs --->")
axes[0].set_ylabel("--- Validation Accuracy --->")
axes[0].legend()

axes[1].grid(True)
axes[1].set_xlabel("--- Epochs --->")
axes[1].set_ylabel("--- Training Accuracy --->")
axes[1].legend()

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.examples.tutorials.mnist import input_data
import time

mnist=input_data.read_data_sets("MNIST_data")

import time
import matplotlib.animation as animation


ims=[]
for i in range(20):
  im = plt.imshow(mnist.train._images[i].reshape(28,28),cmap=plt.cm.binary, animated=True)
  ims.append([im])
ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,
                                repeat_delay=1000)

ani.save('dynamic_images.mp4')

plt.show()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig = plt.figure()


def f(x, y):
    return np.sin(x) + np.cos(y)

x = np.linspace(0, 2 * np.pi, 120)
y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)
# ims is a list of lists, each row is a list of artists to draw in the
# current frame; here we are just animating one artist, the image, in
# each frame
ims = []
for i in range(60):
    x += np.pi / 15.
    y += np.pi / 20.
    im = plt.imshow(f(x, y), animated=True)
    ims.append([im])

ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,
                                repeat_delay=1000)

# ani.save('dynamic_images.mp4')

plt.show()

